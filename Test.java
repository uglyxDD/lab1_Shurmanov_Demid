
//                       ЗАДАНИЕ 1

public class Test {
//    #1.1 Дробная часть.
//    Дана сигнатура метода: public double fraction (double x);
//    Необходимо реализовать метод таким образом, чтобы он возвращал только
//    дробную часть числа х. Подсказка: вещественное число может быть
//    преобразовано к целому путем отбрасывания дробной части.

    public double fraction(double x) {
        return x - (int) x;
    }
//    #3.1 Букву в число.
//    Дана сигнатура метода: public int charToNum (char x);
//    Метод принимает символ х, который представляет собой один из “0 1 2 3 4 5 6 8 9”.
//    Необходимо реализовать метод таким образом, чтобы он преобразовывал
//    символ в соответствующее число. Подсказка: код символа ‘0’ — это число 48.

    public int charToNum(char x) {
        return (char) (x - 48);
    }
//    #5.1 Дана сигнатура метода: public bool is2Digits (int x);
//    Необходимо реализовать метод таким образом, чтобы он принимал число x и
//    возвращал true, если оно двузначное. (boolean)

    public boolean is2Digits(int x) {
        return (x >= 10 && x<= 99) || (x <= -10 && x> -99);
    }
//    #7.1 Дана сигнатура метода: public bool isInRange (int a, int b, int num);
//    Метод принимает левую и правую границу (a и b) некоторого числового
//    диапазона. Необходимо реализовать метод таким образом, чтобы он возвращал
//    true, если num входит в указанный диапазон (включая границы). Обратите
//    внимание, что отношение a и b заранее неизвестно (неясно кто из них больше, а кто меньше)
    public boolean isInRange(int a, int b, int num) {
        int left = Math.min(a, b);
        int right = Math.max(a, b);
        return num >= left && num <= right;
    }

//    #9.1 Дана сигнатура метода: public bool isEqual(int a, int b, int c);
//    Необходимо реализовать метод таким образом, чтобы он возвращал true, если
//    все три полученных методом числа равны
    public boolean isEqual(int fir, int sec, int thr) {
        return (fir == sec) && (sec == thr) ;
    }

    //                     ЗАДАНИЕ 2

//    #1.2 Дана сигнатура метода: public int abs (int x);
//    Необходимо реализовать метод таким образом, чтобы он возвращал модуль
//    числа х (если оно было положительным, то таким и остается, если он было
//    отрицательным – то необходимо вернуть его без знака минус).
    public int abs (int x) {
        int sign;
        if (x < 0) {
            sign = -1;
        }
        else if (x > 0) {
            sign = 1;
        }
        else {
            sign = 0;
        }

        return switch (sign) {
            case -1 -> -x;
            case 1 -> x;
            case 0 -> 0;
            default -> x;
        };
    }
//    #3.2 Дана сигнатура метода: public bool is35 (int x);
//    Необходимо реализовать метод таким образом, чтобы он возвращал true, если
//    число x делится нацело на 3 или 5. При этом, если оно делится и на 3, и на 5, то
//    вернуть надо false. Подсказка: оператор % позволяет получить остаток от
//    деления.

    public boolean is35 (int x) {
        boolean del3 = (x % 3 == 0);
        boolean del5 = (x % 5 == 0);

        int code = 0;
        if (del3) code += 1;
        if (del5) code += 2;

        return switch (code) {
            case 1, 2 -> true;
            case 3 -> false;
            default -> false;
        };

    }

//    #5.2 Дана сигнатура метода: public int max3 (int x, int y, int z);
//    Необходимо реализовать метод таким образом, чтобы он возвращал
//    максимальное из трех полученных методом чисел. Подсказка: идеальное
//    решение включает всего две инструкции if и не содержит вложенных if.
    public int max3 (int x, int y, int z) {
        int max = x;

        if (y > max) max = y;
        if (z > max) max = z;

        return max;
    }


//    #7.2 Дана сигнатура метода: public int sum2 (int x, int y);
//    Необходимо реализовать метод таким образом, чтобы он возвращал сумму
//    чисел x и y. Однако, если сумма попадает в диапазон от 10 до 19, то надо вернуть
//    число 20.
    public int sum2 (int x, int y) {
        int sum = x + y;
        if (sum >= 10 && sum <= 19) {
            return 20;
        }
        return sum;
    }

//    #9.2 Дана сигнатура метода: public String day (int x);
//    Метод принимает число x, обозначающее день недели. Необходимо реализовать
//    метод таким образом, чтобы он возвращал строку, которая будет обозначать
//    текущий день недели, где 1- это понедельник, а 7 – воскресенье. Если число не
//    от 1 до 7 то верните текст “это не день недели”. Вместо if в данной задаче
//    используйте switch.
    public String day (int x) {
        switch (x) {
            case 1: return "Понедельник";
            case 2: return "Вторник";
            case 3: return "Среда";
            case 4: return "Четверг";
            case 5: return "Пятница";
            case 6: return "Суббота";
            case 7: return "Воскресенье";
            default: return "это не день недели";
        }
    }
//    #1.3 Дана сигнатура метода: public String listNums (int x);
//    Необходимо реализовать метод таким образом, чтобы он возвращал строку, в
//    которой будут записаны все числа от 0 до x (включительно).
    public String listNums (int x) {
        StringBuilder sb = new StringBuilder();

        for (int i = 0; i <= x; i++) {
            sb.append(i);
            if (i < x) {
                sb.append(" ");
            }
        }
        return sb.toString();
    }

//    #3.3 Дана сигнатура метода: public String chet (int x);
//    Необходимо реализовать метод таким образом, чтобы он возвращал строку, в
//    которой будут записаны все четные числа от 0 до x (включительно). Подсказа
//    для обеспечения качества кода: инструкцию if использовать не следует.
    public String chet (int x) {
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i <= x; i += 2) {
            sb.append(i);
            if (i + 2 <= x) {
                sb.append(" ");
            }
        }
        return sb.toString();
    }

//    #5.3 Дана сигнатура метода: public int numLen (long x);
//    Необходимо реализовать метод таким образом, чтобы он возвращал количество
//    знаков в числе x.
//    Подсказка:
//    Int у=123/10; // у будет иметь значение 12
    public int numLen (long x) {
        if (x < 0) {
            x = -x;
        }
        if (x == 0) {
            return 1;
        }
        int count = 0;

        while (x > 0) {
            x = x / 10;
            count++;
        }
        return count;
        }
//    #7.3 Дана сигнатура метода: public void square (int x);
//    Необходимо реализовать метод таким образом, чтобы он выводил на экран
//    квадрат из символов ‘*’ размером х, у которого х символов в ряд и х символов в
//    высоту.
    public void square (int x) {
        char[][] square = new char[x][x];
        for (int i = 0; i < x; i++) {
            for (int j = 0; j < x; j++) {
                square[i][j] = '*';
            }
        }
        for (int i = 0; i < x; i++) {
            for (int j = 0; j < x; j++) {
                System.out.print(square[i][j]);
            }
            System.out.println();
        }
    }

//    #9.3 Дана сигнатура метода: public void rightTriangle (int x);
//    Необходимо реализовать метод таким образом, чтобы он выводил на экран
//    треугольник из символов ‘*’ у которого х символов в высоту, а количество
//    символов в ряду совпадает с номером строки, при этом треугольник выровнен
//    по правому краю. Подсказка: перед символами ‘*’ следует выводить
//    необходимое количество пробелов.
    public void rightTriangle (int x) {
            for (int i = 1; i <= x; i++) {         // цикл i
                for (int j = 0; j < x - i; j++) {
                    System.out.print(" ");
                }
                for (int j = 0; j < i; j++) {
                    System.out.print("*");
                }
                System.out.println();
            }
        }
//    #1.4 Дана сигнатура метода: public int findFirst (int[] arr, int x);
//    Необходимо реализовать метод таким образом, чтобы он возвращал индекс
//    первого вхождения числа x в массив arr. Если число не входит в массив –
//    возвращается -1.
    public int findFirst (int[] arr, int x){
        for (int i = 0; i < arr.length; i++) {
            if (arr[i] == x) {
                return i;
            }
        }
        return -1;
    }
}
